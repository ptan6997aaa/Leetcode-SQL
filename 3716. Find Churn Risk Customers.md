```md
3716. Find Churn Risk Customers 
Table: subscription_events

+------------------+---------+
| Column Name      | Type    | 
+------------------+---------+
| event_id         | int     |
| user_id          | int     |
| event_date       | date    |
| event_type       | varchar |
| plan_name        | varchar |
| monthly_amount   | decimal |
+------------------+---------+
event_id is the unique identifier for this table.
event_type can be start, upgrade, downgrade, or cancel.
plan_name can be basic, standard, premium, or NULL (when event_type is cancel).
monthly_amount represents the monthly subscription cost after this event.
For cancel events, monthly_amount is 0.
Write a solution to Find Churn Risk Customers - users who show warning signs before churning. A user is considered churn risk customer if they meet ALL the following criteria:

Currently have an active subscription (their last event is not cancel).
Have performed at least one downgrade in their subscription history.
Their current plan revenue is less than 50% of their historical maximum plan revenue.
Have been a subscriber for at least 60 days.
Return the result table ordered by days_as_subscriber in descending order, then by user_id in ascending order.

The result format is in the following example.

 

Example:

Input:

subscription_events table:

+----------+---------+------------+------------+-----------+----------------+
| event_id | user_id | event_date | event_type | plan_name | monthly_amount |
+----------+---------+------------+------------+-----------+----------------+
| 1        | 501     | 2024-01-01 | start      | premium   | 29.99          |
| 2        | 501     | 2024-02-15 | downgrade  | standard  | 19.99          |
| 3        | 501     | 2024-03-20 | downgrade  | basic     | 9.99           |
| 4        | 502     | 2024-01-05 | start      | standard  | 19.99          |
| 5        | 502     | 2024-02-10 | upgrade    | premium   | 29.99          |
| 6        | 502     | 2024-03-15 | downgrade  | basic     | 9.99           |
| 7        | 503     | 2024-01-10 | start      | basic     | 9.99           |
| 8        | 503     | 2024-02-20 | upgrade    | standard  | 19.99          |
| 9        | 503     | 2024-03-25 | upgrade    | premium   | 29.99          |
| 10       | 504     | 2024-01-15 | start      | premium   | 29.99          |
| 11       | 504     | 2024-03-01 | downgrade  | standard  | 19.99          |
| 12       | 504     | 2024-03-30 | cancel     | NULL      | 0.00           |
| 13       | 505     | 2024-02-01 | start      | basic     | 9.99           |
| 14       | 505     | 2024-02-28 | upgrade    | standard  | 19.99          |
| 15       | 506     | 2024-01-20 | start      | premium   | 29.99          |
| 16       | 506     | 2024-03-10 | downgrade  | basic     | 9.99           |
+----------+---------+------------+------------+-----------+----------------+
Output:

+----------+--------------+------------------------+-----------------------+--------------------+
| user_id  | current_plan | current_monthly_amount | max_historical_amount | days_as_subscriber |
+----------+--------------+------------------------+-----------------------+--------------------+
| 501      | basic        | 9.99                   | 29.99                 | 79                 |
| 502      | basic        | 9.99                   | 29.99                 | 69                 |
+----------+--------------+------------------------+-----------------------+--------------------+
Explanation:

User 501:
Currently active: Last event is downgrade to basic (not cancelled) 
Has downgrades: Yes, 2 downgrades in history 
Current revenue (9.99) vs max (29.99): 9.99/29.99 = 33.3% (less than 50%) 
Days as subscriber: Jan 1 to Mar 20 = 79 days (at least 60) 
Result: Churn Risk Customer
User 502:
Currently active: Last event is downgrade to basic (not cancelled) 
Has downgrades: Yes, 1 downgrade in history 
Current revenue (9.99) vs max (29.99): 9.99/29.99 = 33.3% (less than 50%) 
Days as subscriber: Jan 5 to Mar 15 = 70 days (at least 60) 
Result: Churn Risk Customer
User 503:
Currently active: Last event is upgrade to premium (not cancelled) 
Has downgrades: No downgrades in history 
Result: Not at-risk (no downgrade history)
User 504:
Currently active: Last event is cancel
Result: Not at-risk (subscription cancelled)
User 505:
Currently active: Last event is 'upgrade' to standard (not cancelled) 
Has downgrades: No downgrades in history 
Result: Not at-risk (no downgrade history)
User 506:
Currently active: Last event is downgrade to basic (not cancelled) 
Has downgrades: Yes, 1 downgrade in history 
Current revenue (9.99) vs max (29.99): 9.99/29.99 = 33.3% (less than 50%) 
Days as subscriber: Jan 20 to Mar 10 = 50 days (less than 60) 
Result: Not at-risk (insufficient subscription duration)
Result table is ordered by days_as_subscriber DESC, then user_id ASC.

Note: days_as_subscriber is calculated from the first event date to the last event date for each user
```

```sql
# Write your MySQL query statement below
WITH add_index AS (
    SELECT 
        user_id,
        event_type, 
        plan_name, 
        monthly_amount, 
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_date DESC) AS group_index  
    FROM subscription_events  
),
keep_last_type AS (
    SELECT user_id, event_type, plan_name, monthly_amount  
    FROM add_index 
    WHERE group_index = 1   
), 
active_subscription AS (
    SELECT user_id, plan_name, monthly_amount   
    FROM keep_last_type 
    WHERE event_type != 'cancel'  
), 
check_downgrade AS (
    SELECT user_id, event_type 
    FROM subscription_events 
    GROUP BY user_id, event_type    
), 
downgrade_user_id AS (
    SELECT user_id 
    FROM check_downgrade  
    WHERE event_type = 'downgrade' 
), 
max_revenue AS (
    SELECT user_id AS id, MAX(monthly_amount) AS max_rev 
    FROM subscription_events 
    GROUP BY user_id     
), 
join_one AS (
    SELECT id, max_rev 
    FROM max_revenue 
    INNER JOIN downgrade_user_id ON id = user_id      
), 
join_two AS (
    SELECT user_id, plan_name AS current_plan, monthly_amount AS current_monthly_amount, max_rev AS max_historical_amount  
    FROM active_subscription 
    INNER JOIN join_one ON id = user_id       
), 
calculate_rev AS (
    SELECT * 
    FROM join_two 
    WHERE current_monthly_amount < 0.5 * max_historical_amount     
), 
count_days_max AS (
    SELECT user_id, MAX(event_date) AS max_day  
    FROM subscription_events 
    GROUP BY user_id   
), 
count_days_min AS (
    SELECT user_id, MIN(event_date) AS min_day  
    FROM subscription_events 
    GROUP BY user_id   
), 
count_days_join AS (
    SELECT count_days_max.user_id, max_day, min_day  
    FROM count_days_max 
    INNER JOIN count_days_min ON count_days_max.user_id = count_days_min.user_id        
), 
count_days AS (
    SELECT user_id, DATEDIFF(max_day, min_day) AS days_as_subscriber 
    FROM count_days_join 
    WHERE DATEDIFF(max_day, min_day) >= 60   
), 
join_three AS (
    SELECT calculate_rev.user_id, current_plan, current_monthly_amount, max_historical_amount, days_as_subscriber     
    FROM calculate_rev 
    INNER JOIN count_days ON calculate_rev.user_id = count_days.user_id     
)
SELECT * 
FROM join_three   
ORDER BY days_as_subscriber DESC, user_id ASC 
```

```py
import pandas as pd
import numpy as np

def find_churn_risk_customers(subscription_events: pd.DataFrame) -> pd.DataFrame:
    # Currently have an active subscription 
    current_active = subscription_events[['user_id', 'event_date', 'event_type', 'plan_name', 'monthly_amount']].copy()
    current_active = current_active.sort_values(['user_id', 'event_date'], ascending=[True, False])
    current_active['row_num'] = current_active.groupby('user_id').cumcount() + 1 
    current_active = current_active.loc[
        (current_active['row_num'] == 1) & 
        (current_active['event_type'] != 'cancel')
    ]
    current_active = current_active[['user_id', 'plan_name', 'monthly_amount']] 
    current_active = current_active.rename(columns={'plan_name': 'current_plan', 'monthly_amount': 'current_monthly_amount'})
    # Have performed at least one downgrade 
    perform_downgrade = subscription_events[['user_id', 'event_type']].copy() 
    perform_downgrade['check_downgrade'] = np.where(
        perform_downgrade['event_type'].eq('downgrade'),
        1, 
        0
    )
    perform_downgrade = perform_downgrade.groupby('user_id').agg(
        sum_downgrade=('check_downgrade', 'sum')
    ).reset_index()
    perform_downgrade = perform_downgrade.loc[perform_downgrade['sum_downgrade'] >= 1]   
    perform_downgrade = perform_downgrade[['user_id']] 
    # Their current plan revenue is less than 50% of their historical maximum plan revenue 
    current_vs_max_revenue = subscription_events.groupby('user_id').agg(
        max_historical_amount=('monthly_amount', 'max')
    ).reset_index()
    current_vs_max_revenue = current_active.merge(current_vs_max_revenue, how='inner', on='user_id') 
    current_vs_max_revenue = current_vs_max_revenue.loc[
        current_vs_max_revenue['current_monthly_amount'] < current_vs_max_revenue['max_historical_amount'] * 0.5 
    ]
    # Have been a subscriber for at least 60 days 
    subscriber_days = subscription_events.groupby('user_id').agg(
        max_date=('event_date', 'max'),
        min_date=('event_date', 'min')
    ).reset_index()
    subscriber_days['max_date'] = pd.to_datetime(subscriber_days['max_date'])
    subscriber_days['min_date'] = pd.to_datetime(subscriber_days['min_date'])
    subscriber_days['days_as_subscriber'] = (subscriber_days['max_date'] - subscriber_days['min_date']).dt.days 
    subscriber_days = subscriber_days.loc[subscriber_days['days_as_subscriber'] >= 60] 
    subscriber_days = subscriber_days[['user_id', 'days_as_subscriber']] 
    # output 
    output = current_vs_max_revenue.merge(perform_downgrade, how='inner', on='user_id')
    output = output.merge(subscriber_days, how='inner', on='user_id') 
    output = output.sort_values(['days_as_subscriber', 'user_id'], ascending=[False, True])       
    return output  
   ```


